# Snapshot report for `dist/codegen/generators/__tests__/typescript-client.connection.test.js`

The actual snapshot is saved in `typescript-client.connection.test.js.snap`.

Generated by [AVA](https://ava.li).

## typescript generator - connection

> Snapshot 1

    `// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.␊
    // Please don't change this file manually but run `prisma generate` to update it.␊
    // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/␊
    ␊
    import { DocumentNode } from "graphql";␊
    import {␊
      makePrismaClientClass,␊
      BaseClientOptions,␊
      Model␊
    } from "prisma-client-lib";␊
    import { typeDefs } from "./prisma-schema";␊
    ␊
    export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &␊
      U[keyof U];␊
    ␊
    export interface Exists {}␊
    ␊
    export interface Node {}␊
    ␊
    export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;␊
    ␊
    export interface Fragmentable {␊
      $fragment<T>(fragment: string | DocumentNode): Promise<T>;␊
    }␊
    ␊
    export interface Prisma {␊
      $exists: Exists;␊
      $graphql: <T = any>(␊
        query: string,␊
        variables?: { [key: string]: any }␊
      ) => Promise<T>;␊
    ␊
      /**␊
       * Queries␊
       */␊
    ␊
      usersConnection: (where?: UserWhereInput) => UserConnectionPromise;␊
      housesConnection: (where?: HouseWhereInput) => HouseConnectionPromise;␊
    ␊
      /**␊
       * Mutations␊
       */␊
    ␊
      /**␊
       * Subscriptions␊
       */␊
    ␊
      $subscribe: Subscription;␊
    }␊
    ␊
    export interface Subscription {}␊
    ␊
    export interface ClientConstructor<T> {␊
      new (options?: BaseClientOptions): T;␊
    }␊
    ␊
    /**␊
     * Types␊
     */␊
    ␊
    export interface HouseWhereInput {␊
      id: ID_Input;␊
    }␊
    ␊
    export interface UserWhereInput {␊
      id: ID_Input;␊
    }␊
    ␊
    export interface User {}␊
    ␊
    export interface UserPromise extends Promise<User>, Fragmentable {␊
      house: <T = HousePromise>() => T;␊
    }␊
    ␊
    export interface UserSubscription␊
      extends Promise<AsyncIterator<User>>,␊
        Fragmentable {␊
      house: <T = HouseSubscription>() => T;␊
    }␊
    ␊
    export interface AggregateUser {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregateUserPromise␊
      extends Promise<AggregateUser>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregateUserSubscription␊
      extends Promise<AsyncIterator<AggregateUser>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface AggregateHouse {␊
      count: Int;␊
    }␊
    ␊
    export interface AggregateHousePromise␊
      extends Promise<AggregateHouse>,␊
        Fragmentable {␊
      count: () => Promise<Int>;␊
    }␊
    ␊
    export interface AggregateHouseSubscription␊
      extends Promise<AsyncIterator<AggregateHouse>>,␊
        Fragmentable {␊
      count: () => Promise<AsyncIterator<Int>>;␊
    }␊
    ␊
    export interface PageInfo {␊
      hasNextPage: Boolean;␊
      hasPreviousPage: Boolean;␊
      startCursor?: String;␊
      endCursor?: String;␊
    }␊
    ␊
    export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {␊
      hasNextPage: () => Promise<Boolean>;␊
      hasPreviousPage: () => Promise<Boolean>;␊
      startCursor: () => Promise<String>;␊
      endCursor: () => Promise<String>;␊
    }␊
    ␊
    export interface PageInfoSubscription␊
      extends Promise<AsyncIterator<PageInfo>>,␊
        Fragmentable {␊
      hasNextPage: () => Promise<AsyncIterator<Boolean>>;␊
      hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;␊
      startCursor: () => Promise<AsyncIterator<String>>;␊
      endCursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface HouseEdge {␊
      node: House;␊
      cursor: String;␊
    }␊
    ␊
    export interface HouseEdgePromise extends Promise<HouseEdge>, Fragmentable {␊
      node: <T = HousePromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    export interface HouseEdgeSubscription␊
      extends Promise<AsyncIterator<HouseEdge>>,␊
        Fragmentable {␊
      node: <T = HouseSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    export interface HouseConnection {␊
      pageInfo: PageInfo;␊
      edges: HouseEdge[];␊
    }␊
    ␊
    export interface HouseConnectionPromise␊
      extends Promise<HouseConnection>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoPromise>() => T;␊
      edges: <T = FragmentableArray<HouseEdge>>() => T;␊
      aggregate: <T = AggregateHousePromise>() => T;␊
    }␊
    ␊
    export interface HouseConnectionSubscription␊
      extends Promise<AsyncIterator<HouseConnection>>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoSubscription>() => T;␊
      edges: <T = Promise<AsyncIterator<HouseEdgeSubscription>>>() => T;␊
      aggregate: <T = AggregateHouseSubscription>() => T;␊
    }␊
    ␊
    export interface UserConnection {}␊
    ␊
    export interface UserConnectionPromise␊
      extends Promise<UserConnection>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoPromise>() => T;␊
      edges: <T = FragmentableArray<UserEdge>>() => T;␊
      aggregate: <T = AggregateUserPromise>() => T;␊
    }␊
    ␊
    export interface UserConnectionSubscription␊
      extends Promise<AsyncIterator<UserConnection>>,␊
        Fragmentable {␊
      pageInfo: <T = PageInfoSubscription>() => T;␊
      edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;␊
      aggregate: <T = AggregateUserSubscription>() => T;␊
    }␊
    ␊
    export interface House {␊
      id: ID_Output;␊
      name: String;␊
    }␊
    ␊
    export interface HousePromise extends Promise<House>, Fragmentable {␊
      id: () => Promise<ID_Output>;␊
      name: () => Promise<String>;␊
      user: <T = UserPromise>() => T;␊
    }␊
    ␊
    export interface HouseSubscription␊
      extends Promise<AsyncIterator<House>>,␊
        Fragmentable {␊
      id: () => Promise<AsyncIterator<ID_Output>>;␊
      name: () => Promise<AsyncIterator<String>>;␊
      user: <T = UserSubscription>() => T;␊
    }␊
    ␊
    export interface UserEdge {␊
      node: User;␊
      cursor: String;␊
    }␊
    ␊
    export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {␊
      node: <T = UserPromise>() => T;␊
      cursor: () => Promise<String>;␊
    }␊
    ␊
    export interface UserEdgeSubscription␊
      extends Promise<AsyncIterator<UserEdge>>,␊
        Fragmentable {␊
      node: <T = UserSubscription>() => T;␊
      cursor: () => Promise<AsyncIterator<String>>;␊
    }␊
    ␊
    /*␊
    The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. ␊
    */␊
    export type Int = number;␊
    ␊
    /*␊
    The `Boolean` scalar type represents `true` or `false`.␊
    */␊
    export type Boolean = boolean;␊
    ␊
    /*␊
    The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.␊
    */␊
    export type ID_Input = string | number;␊
    export type ID_Output = string;␊
    ␊
    /*␊
    The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.␊
    */␊
    export type String = string;␊
    ␊
    /**␊
     * Model Metadata␊
     */␊
    ␊
    export const models: Model[] = [];␊
    ␊
    /**␊
     * Type Defs␊
     */␊
    ␊
    export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({␊
      typeDefs,␊
      models␊
    });␊
    export const prisma = new Prisma();␊
    `
